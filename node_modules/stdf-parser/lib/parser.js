"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StdfParser = void 0;
const smart_buffer_1 = require("smart-buffer");
const stream_1 = require("stream");
const constants_1 = require("./constants");
const error_1 = require("./error");
const record_factory_1 = require("./record-factory");
const far_record_1 = require("./records/far.record");
const stdf_file_1 = require("./stdf-file");
const util_1 = require("./util");
class StdfParser extends stream_1.Transform {
    buffer = Buffer.alloc(0);
    _offset = 0;
    _endian;
    constructor() {
        super({
            objectMode: true,
            transform: (chunk, encoding, callback) => {
                try {
                    this.buffer = Buffer.concat([this.buffer, chunk]);
                    if (this._endian === undefined) {
                        const head = this.buffer.readUInt16LE();
                        if (head === 0x0002) {
                            this._endian = constants_1.EnumEndian.little;
                        }
                        else if (head === 0x0200) {
                            this._endian = constants_1.EnumEndian.big;
                        }
                        else {
                            return callback(new error_1.InvalidStdfFileError('invalid stdf file', this._offset));
                        }
                    }
                    const records = this.doParse();
                    for (const record of records) {
                        this.push(record);
                    }
                    return callback();
                }
                catch (e) {
                    return callback(new error_1.InvalidStdfFileError('read file error', this._offset, { cause: e }));
                }
            },
            flush: (callback) => {
                try {
                    const records = this.doParse();
                    for (const record of records) {
                        this.push(record);
                    }
                    return callback();
                }
                catch (e) {
                    return callback(new error_1.InvalidStdfFileError('read file error', this._offset, { cause: e }));
                }
            },
        });
    }
    get endian() {
        return this._endian;
    }
    get offset() {
        return this._offset;
    }
    static parse(buffer) {
        const file = new stdf_file_1.StdfFile();
        const sb = smart_buffer_1.SmartBuffer.fromBuffer(buffer);
        let endian = undefined;
        try {
            while (sb.remaining() > 0) {
                let len;
                if (endian === undefined) {
                    len = sb.readUInt16LE();
                    if (len === 0x0002) {
                        endian = constants_1.EnumEndian.little;
                    }
                    else if (len === 0x0200) {
                        len = 0x0002;
                        endian = constants_1.EnumEndian.big;
                    }
                    else {
                        throw new Error('cannot detect endian');
                    }
                }
                else {
                    if (endian === constants_1.EnumEndian.little) {
                        len = sb.readUInt16LE();
                    }
                    else {
                        len = sb.readUInt16BE();
                    }
                }
                const data = sb.readBuffer(len + 2);
                const record = (0, record_factory_1.parseBuffer)(data, endian);
                switch (record.subType) {
                    case constants_1.EnumRecordType.far: {
                        const farRecord = record;
                        file.cpuType = farRecord.cpuType;
                        file.version = farRecord.version;
                        break;
                    }
                    case constants_1.EnumRecordType.atr: {
                        file.atr = record;
                        break;
                    }
                    case constants_1.EnumRecordType.mir: {
                        file.mir = record;
                        break;
                    }
                    case constants_1.EnumRecordType.sdr: {
                        file.sdr = record;
                        break;
                    }
                    default:
                        file.records.push(record);
                }
            }
        }
        catch (e) {
            throw new error_1.InvalidStdfFileError('parser error', sb.readOffset, { cause: e });
        }
        return file;
    }
    static stream() {
        return new StdfParser();
    }
    static isStdfV4(buffer) {
        const buf = smart_buffer_1.SmartBuffer.fromBuffer(buffer);
        if (buf.length < 4)
            return false;
        let size = buf.readUInt16LE();
        let endian;
        if (size === 0x0002) {
            endian = constants_1.EnumEndian.little;
        }
        else if (size === 0x0200) {
            size = 0x0002;
            endian = constants_1.EnumEndian.big;
        }
        else {
            return false;
        }
        if (buf.length < 4 + size)
            return false;
        const data = buffer.subarray(2, size + 4);
        const record = (0, record_factory_1.parseBuffer)(data, endian);
        return record instanceof far_record_1.FarRecord && record.version === 4;
    }
    doParse() {
        const chunk = [];
        for (let size = this.buffer.length >= 4 ? (0, util_1.readUIn16)(this.buffer, this._endian) : 0; this.buffer.length >= size + 4; size = this.buffer.length >= 4 ? (0, util_1.readUIn16)(this.buffer, this._endian) : 0) {
            const data = this.buffer.slice(2, size + 4);
            const record = (0, record_factory_1.parseBuffer)(data, this._endian);
            chunk.push(record);
            this.buffer = this.buffer.slice(4 + size);
            this._offset += size + 4;
        }
        return chunk;
    }
}
exports.StdfParser = StdfParser;
//# sourceMappingURL=parser.js.map