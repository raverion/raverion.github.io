"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StdfSlicer = void 0;
const web_1 = require("stream/web");
const constants_1 = require("./constants");
const error_1 = require("./error");
const util_1 = require("./util");
class StdfSlicer extends web_1.TransformStream {
    buffer = Buffer.alloc(0);
    _offset = 0;
    _endian;
    constructor() {
        super({
            transform: async (chunk, controller) => {
                this.buffer = Buffer.concat([this.buffer, Buffer.from(await chunk.arrayBuffer())]);
                if (this._endian === undefined) {
                    const head = this.buffer.readUInt16LE();
                    if (head === 0x0002) {
                        this._endian = constants_1.EnumEndian.little;
                    }
                    else if (head === 0x0200) {
                        this._endian = constants_1.EnumEndian.big;
                    }
                    else {
                        throw new error_1.InvalidStdfFileError('invalid stdf file', this._offset);
                    }
                }
                try {
                    const records = this.doParse();
                    for (const record of records) {
                        controller.enqueue(record);
                    }
                }
                catch (e) {
                    throw new error_1.InvalidStdfFileError('read file error', this._offset, { cause: e });
                }
            },
            flush: (controller) => {
                try {
                    const records = this.doParse();
                    for (const record of records) {
                        controller.enqueue(record);
                    }
                }
                catch (e) {
                    throw new error_1.InvalidStdfFileError('read file error', this._offset, { cause: e });
                }
            },
        });
    }
    get endian() {
        return this._endian;
    }
    get offset() {
        return this._offset;
    }
    doParse() {
        const chunk = [];
        for (let size = this.buffer.length >= 4 ? (0, util_1.readUIn16)(this.buffer, this._endian) : 0; this.buffer.length >= size + 4; size = this.buffer.length >= 4 ? (0, util_1.readUIn16)(this.buffer, this._endian) : 0) {
            const data = this.buffer.slice(2, size + 4);
            chunk.push({ offset: this._offset, buffer: data });
            this.buffer = this.buffer.slice(4 + size);
            this._offset += size + 4;
        }
        return chunk;
    }
}
exports.StdfSlicer = StdfSlicer;
//# sourceMappingURL=slicer.js.map