"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BufferReader = void 0;
const lodash_1 = require("lodash");
const smart_buffer_1 = require("smart-buffer");
const constants_1 = require("./constants");
class BufferReader {
    endian;
    buffer;
    constructor(buffer, endian) {
        this.endian = endian;
        if (buffer instanceof smart_buffer_1.SmartBuffer) {
            this.buffer = buffer;
        }
        else {
            this.buffer = smart_buffer_1.SmartBuffer.fromBuffer(buffer);
        }
    }
    readFixedString(length = 12) {
        if (this.buffer.remaining() === 0)
            return undefined;
        if (length === 0)
            return '';
        return this.buffer.readString(length).trimStart();
    }
    readVarString() {
        if (this.buffer.remaining() === 0)
            return;
        const length = this.buffer.readUInt8();
        if (length === 0)
            return '';
        return this.buffer.readString(length);
    }
    readVarChar() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.readVarString();
    }
    readUInt8() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.buffer.readUInt8();
    }
    readUInt16() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.endian === constants_1.EnumEndian.little ? this.buffer.readUInt16LE() : this.buffer.readUInt16BE();
    }
    readUInt32() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.endian === constants_1.EnumEndian.little ? this.buffer.readUInt32LE() : this.buffer.readUInt32BE();
    }
    readInt8() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.buffer.readInt8();
    }
    readInt16() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.endian === constants_1.EnumEndian.little ? this.buffer.readInt16LE() : this.buffer.readInt16BE();
    }
    readInt32() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.endian === constants_1.EnumEndian.little ? this.buffer.readInt32LE() : this.buffer.readInt32BE();
    }
    readFloat() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.endian === constants_1.EnumEndian.little ? this.buffer.readFloatLE() : this.buffer.readFloatBE();
    }
    readDouble() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.endian === constants_1.EnumEndian.little ? this.buffer.readDoubleLE() : this.buffer.readDoubleBE();
    }
    readFixedBuffer(length = 6) {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.buffer.readBuffer(length);
    }
    readVarBuffer() {
        if (this.buffer.remaining() === 0)
            return undefined;
        const length = this.readUInt8();
        if (!length)
            return undefined;
        return this.buffer.readBuffer(length);
    }
    readBitBuffer() {
        if (this.buffer.remaining() === 0)
            return undefined;
        const length = this.readUInt16();
        if (!length)
            return undefined;
        return this.buffer.readBuffer(Math.ceil(length / 8));
    }
    readDate() {
        if (this.buffer.remaining() === 0)
            return undefined;
        const ts = this.readUInt32();
        if (ts === undefined)
            return undefined;
        return new Date(ts * 1000);
    }
    readChar() {
        if (this.buffer.remaining() === 0)
            return undefined;
        return this.readFixedString(1);
    }
    readNibble() {
        if (this.buffer.remaining() === 0)
            return undefined;
        const buf = this.readUInt8();
        if (buf === undefined)
            return undefined;
        return [buf & 0b00001111, buf >> 4];
    }
    readVarData(length) {
        if (this.buffer.remaining() === 0)
            return undefined;
        const res = new Array(length);
        for (let i = 0; i < length; i++) {
            const type = this.readUInt8();
            switch (type) {
                case 0:
                    break;
                case 1:
                    res[i] = this.readUInt8();
                    break;
                case 2:
                    res[i] = this.readUInt16();
                    break;
                case 3:
                    res[i] = this.readUInt32();
                    break;
                case 4:
                    res[i] = this.readInt8();
                    break;
                case 5:
                    res[i] = this.readInt16();
                    break;
                case 6:
                    res[i] = this.readInt32();
                    break;
                case 7:
                    res[i] = this.readFloat();
                    break;
                case 8:
                    res[i] = this.readDouble();
                    break;
                case 10:
                    res[i] = this.readVarString();
                    break;
                case 11:
                    res[i] = this.readVarBuffer();
                    break;
                case 12:
                    res[i] = this.readBitBuffer();
                    break;
                case 13:
                    res[i] = this.readNibble();
                    break;
                default:
                    throw new Error(`unknown variable data type: ${(0, lodash_1.toString)(type)}, maybe new stdf version?`);
            }
        }
        return res;
    }
    remaining() {
        return this.buffer.remaining();
    }
}
exports.BufferReader = BufferReader;
//# sourceMappingURL=buffer-reader.js.map